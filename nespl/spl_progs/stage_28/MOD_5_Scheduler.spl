// Pushing BP of current process because expl program does not save the BP while the schduler is called from the timer
multipush(BP);
// 2 Obtain the PID of currently executing process from System Status Table.

// call AQUIRE SCHEDULER LOCK
R1 = ACQUIRE_SCHED_LOCK;
call ACCESS_CONTROL;


alias processTableEntryAddress R1;
processTableEntryAddress = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1] * 16;


// Note that instead of saving the actual value of KPTR, we are saving KPTR%512. This is because the OS design stipulates that KPTR must contain the offset of the kernel stack pointer within the User Area Page. This is done so as to allow the OS to relocate the User Area Page if necessary.
[processTableEntryAddress + 12] = SP % PAGE_SIZE;
[processTableEntryAddress + 14] = PTBR;
[processTableEntryAddress + 15] = PTLR;


alias newPID R2;

alias newProcessTableEntryAddress R3;
alias processStartIterator R4;
alias processEndIterator R6;

newPID = -1;

if(CORE == PRIMARY_CORE) then 
    // IDLE2 (PID=14) must not be scheduled. (IDLE2 is scheduled only in the secondary).

    // The Process which is currently running on the secondary core must not be scheduled (This can be determined by reading CURRENT_PID2 field of the system status table ).

    // If LOGOUT_STATUS=1 and the secondary core is not running IDLE2, then schedule IDLE (wait for the current running process to be scheduled out of the secondary core).
    if([SYSTEM_STATUS_TABLE + 7] == 1 && [SYSTEM_STATUS_TABLE+6] != IDLE2_PROCESS) then
        newPID = IDLE_PROCESS;
    endif;

    processStartIterator = 0;
    processEndIterator = IDLE2_PROCESS; // not inclusive
else // if(CORE == SECONDARY_CORE) then

    // If PAGING_STATUS or LOGOUT_STATUS is set (in the system status table ), then IDLE2 must be scheduled).
    if([SYSTEM_STATUS_TABLE + 5] == 1 || [SYSTEM_STATUS_TABLE + 7] == 1) then
        newPID = IDLE2_PROCESS;
    endif;
    // IDLE (PID=0), LOGIN (PID=1), SHELL (PID=2) and SWAPPER_DAEMON (PID=15) should never be scheduled, as the eXpOS design stipulates that these processes will run only on the primary.
    // Schedule only processes 2-14 (inclusive) on the secondary core.
    // Process which is currently running on the primary core must not be scheduled (read CURRENT_PID field of the system status table ).
    // The PID of the process that is selected for scheduling in the secondary core must be set to CURRENT_PID2 field of the system status table.

    processStartIterator = SHELL_PROCESS+1;
    processEndIterator = SWAPPER_DAEMON; // not inclusive

endif;








// if (PAGING_STATUS in the System Status Table is not 0) (Paging is ongoing )
if( [SYSTEM_STATUS_TABLE + 5] != 0 && CORE == PRIMARY_CORE) then

    // If the paging process is not blocked  ( the paging process is executing a disk operation )
    if([PROCESS_TABLE + 16*SWAPPER_DAEMON +4] != WAIT_DISK) then
        // Choose the Swapper Daemon to be scheduled.
        newPID = SWAPPER_DAEMON;
    else   
        // else  Choose Idle Process for scheduling.
        newPID = IDLE_PROCESS;

    endif;

endif;
    //  Find the next non swapped process to schedule using the Round Robin scheduling technique, 

    // Round Robin algorithm for scheduling

    // Iterate through the Process Table entries, starting from the succeeding entry of the current process to find a process in READY or CREATED state.
    // If no such process can be found, select the idle process as the new process to be scheduled. Save PID of new process to be scheduled as newPID.
if(newPID == -1) then
    alias iter R8;
    alias currentPID R9;
    currentPID = [SYSTEM_STATUS_TABLE + 5*CORE + 1] ;
    iter =  currentPID+1 ; // current id +1

    while(iter< processEndIterator) do
        processTableEntryAddress = PROCESS_TABLE + iter * 16;
        // finding a non swapped process in ready or created state
        if(([processTableEntryAddress+6] == 0) && ([processTableEntryAddress + 4] == READY || [processTableEntryAddress + 4] == CREATED)  ) then
            newPID = iter;
            break;
        endif;
        iter=iter+1;
    endwhile;


    if(newPID == -1) then
        iter = processStartIterator;
        while(iter <  currentPID) do
            processTableEntryAddress = PROCESS_TABLE + iter * 16;
            // finding a non swapped process in ready or created state
            if( ([processTableEntryAddress+6] == 0) && ([processTableEntryAddress + 4] == READY || [processTableEntryAddress + 4] == CREATED)  ) then
                newPID = iter;
                break;
            endif;
            iter=iter+1;
        endwhile;
    endif;

    if(newPID == -1) then
        if(CORE == PRIMARY_CORE) then
            newPID = IDLE_PROCESS;
        else
            newPID = IDLE2_PROCESS;
        endif;
    endif;

endif;





//  Restore the SP, PTBR and PTLR values from the Process Table entry for the new process.
newProcessTableEntryAddress = PROCESS_TABLE + newPID * 16;
//Set back Kernel SP, PTBR , PTLR
SP =  [newProcessTableEntryAddress + 11] * 512 + [newProcessTableEntryAddress + 12] ;
PTBR = [newProcessTableEntryAddress + 14];
PTLR = [newProcessTableEntryAddress + 15];

// Set the PID field of the System Status Table as newPID.
[SYSTEM_STATUS_TABLE + 5*CORE + 1] = newPID;

if([newProcessTableEntryAddress + 4] == CREATED) then
    SP = [newProcessTableEntryAddress +13];

    // Store the value in the first word of the kernel stack to the BP register.
    [newProcessTableEntryAddress + 4] = RUNNING;
    [newProcessTableEntryAddress + 9] = 0; // MODE FLAG
    BP = [[newProcessTableEntryAddress + 11] * 512];

    // calling RELEASE SCHEDULER LOCK
    R1 = RELEASE_LOCK;
    R2 = SCHED_LOCK;
    call ACCESS_CONTROL;


    ireturn;
endif;

[newProcessTableEntryAddress + 4] = RUNNING;

// calling RELEASE SCHEDULER LOCK
R1 = RELEASE_LOCK;
R2 = SCHED_LOCK;
call ACCESS_CONTROL;

multipop(BP);
return;
