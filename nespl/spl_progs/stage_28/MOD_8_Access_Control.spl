// MOD 8 Access Control
alias functionNumber R1; // Function number



// Acquires KERN_LOCK which is a common access variable to be set before running any critical kernel code (except the scheduler)
// Before executing any kernel module/interrupt handler, KERN_LOCK is set (by invoking this function) so that the other core waits till the critical action is completed. After completing the critical kernel code, the ReleaseLock function is used to release KERN_LOCK.
// Called by all system calls, exception handler and timer interrupt handler.
if(functionNumber == ACQUIRE_KERN_LOCK) then
    // Arguements are NIL
    // Returns NIL


    // if (core is SECONDARY_CORE)
    if(CORE == SECONDARY_CORE) then
        // if (PAGING_STATUS or LOGOUT_STATUS is on)
        if([SYSTEM_STATUS_TABLE+5] == 1 || [SYSTEM_STATUS_TABLE+7] ==1) then
            // eXpOS design  does not permit a process to execute critical code on the secondary core when paging or logout is ongoing.

            // Set the state of current process to READY
            alias processTableEntryAddress R2;
            processTableEntryAddress = PROCESS_TABLE + ([SYSTEM_STATUS_TABLE+6] * 16);
            [processTableEntryAddress+4] = READY;

            //  Call the switch_context() function of the Scheduler Module.
            multipush(R1,R2);
            call SCHEDULER;
            multipop(R1,R2);


            // Note that cheduler Module requires appropriate modifications before running on the NEXSM machine 


        endif;

    endif;

    // Spinlock 
    while( tsl (KERN_LOCK) == 1) do
        // Wait till KERN_LOCK is released by the other core
        continue;
    endwhile;


endif;


// Acquires SCHED_LOCK which is an access variable to be set before running the scheduler. This ensures that if one core has set SCHED_LOCK, the other core will not enter the Scheduler module until the first core completes the scheduling action. 
// After completing the scheduling action, the ReleaseLock function is used to release SCHED_LOCK.
if(functionNumber == ACQUIRE_SCHED_LOCK) then
    // Arguements are NIL
    // Returns NIL


    while( tsl (SCHED_LOCK) == 1) do
        // Wait till SCHED_LOCK is released by the other core
        continue;
    endwhile;


endif;

if(functionNumber  == ACQUIRE_GLOCK) then
    // Arguements are NIL
    // Returns NIL
    
    // Acquires GLOCK which is a general purpose lock variable that is currently left unused.
   
    while(tsl(GLOCK) == 1) do
        continue;
    endwhile;

endif;

if(functionNumber == RELEASE_LOCK) then
    // Arguements are LockVarAddress
    // Returns NIL
    // Store 0 to the address LockVarAddress.
    alias lockVarAddress R2;
    [lockVarAddress] = 0;

endif;



return;