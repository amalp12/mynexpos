// Peterson MOD 8
// Access Table Contains
// KERN_LOCK (1 word)	SCHED_LOCK (1 word)	GLOCK (1 word)	Unused (5 word)
// ACCESS_LOCK_TABLE = 29576	

// define TURN_KERN_LOCK ACCESS_LOCK_TABLE; // KERN_LOCK is taken
// define FLAGS_KERN_LOCK (ACCESS_LOCK_TABLE+3); // First 2 unused words
// (ACCESS_LOCK_TABLE+3) G_LOCK is left alone for future use
// define TURN_SCHED_LOCK (ACCESS_LOCK_TABLE+1); // SCHED_LOCK is taken
// define FLAGS_SCHED_LOCK (ACCESS_LOCK_TABLE+5); // Next 2 unused words

define TURN_KERN_LOCK 29576;
define FLAGS_KERN_LOCK 29579;
define TURN_SCHED_LOCK 29577;
define FLAGS_SCHED_LOCK 29581;

alias functionNumber R1;


if(functionNumber == ACQUIRE_KERN_LOCK) then

	alias processTableEntryAddress R3;
	processTableEntryAddress = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16;

	// if logout or paging was initiated then we allow the system to go ahead with it
	// if the core is secondary and the( paging status is on or the logout status is on)
	if(CORE == SECONDARY_CORE && ([SYSTEM_STATUS_TABLE + 5] == 1 || [SYSTEM_STATUS_TABLE + 7] == 1)) then
		// change the status of the current process from RUNNING to READY
		[processTableEntryAddress + 4] = READY;
		// call the scheduler
		multipush(R1,R2,R3);
		call SCHEDULER;
		multipop(R1,R2,R3);
	endif;

	// find the other core
	alias otherCore R2;
	otherCore = 1 - CORE;

	// Set the Ready Flag of the current core to true ( meaning the current program is ready to enter the critical state)
	[FLAGS_KERN_LOCK + CORE] = 1;
	// Then give the turn to enter the critical state to the other core
	// Set the turn lock to the other core
	[TURN_KERN_LOCK] = otherCore;

	// while its the other cores turn wait in a spin lock	
	while([FLAGS_KERN_LOCK + otherCore] == 1 && [TURN_KERN_LOCK] == otherCore) do
		continue;
	endwhile;
	
endif;


if(functionNumber == ACQUIRE_SCHED_LOCK) then

	

	// find the other core
	alias otherCore R2;
	otherCore = 1 - CORE;

	// Set the Ready Flag of the current core to true ( meaning the current program is ready to enter the critical state)
	[FLAGS_SCHED_LOCK + CORE] = 1;
	// Then give the turn to enter the critical state to the other core
	// Set the turn lock to the other core
	[TURN_SCHED_LOCK] = otherCore;

	
	// while its the other cores turn wait in a spin lock
	while([FLAGS_SCHED_LOCK + otherCore] == 1 && [TURN_SCHED_LOCK] == otherCore) do
		continue;
	endwhile;



	
endif;

// not used
if(functionNumber  == ACQUIRE_GLOCK) then
    // Arguements are NIL
    // Returns NIL
    
    // Acquires GLOCK which is a general purpose lock variable that is currently left unused.
   
    while(tsl(GLOCK) == 1) do
        continue;
    endwhile;

endif;

if(functionNumber == RELEASE_LOCK) then
	alias lockVarAddress R2;

	if(lockVarAddress == KERN_LOCK) then
		[FLAGS_KERN_LOCK + CORE] = 0;
	endif;
	if(lockVarAddress == SCHED_LOCK) then
		[FLAGS_SCHED_LOCK + CORE] = 0;
	endif;

	
endif;

return;