// load mod 7 (BOOT_MODULE)
loadi(54,67);
loadi(55,68);

//  Load the idle code from disk to memory.
loadi(69,11);




// setting SP To kernel stack
SP = 76*PAGE_SIZE-1;

// calling boot module
call BOOT_MODULE;

// IDLE
alias iter R1;
iter=IDLE_PROCESS;
while(iter<=SWAPPER_DAEMON) do
    PTBR = PAGE_TABLE_BASE+iter*20; // 29696 //as PID of idle process is 0
    PTLR = 10;
    alias stackPage R2;
    if(iter==IDLE_PROCESS) then
        stackPage = 70;
    endif;
    if(iter==SWAPPER_DAEMON) then
        stackPage = 81;
    endif;
    if(iter==IDLE2_PROCESS) then
        stackPage = 83;
    endif;

    //Library FOR IDLE IS NOT USED
    [PTBR+0] = -1;
    [PTBR+1] = "0000";
    [PTBR+2] = -1;
    [PTBR+3] = "0000";


    // Heap FOR IDLE IS NOT USED
    [PTBR+4] = -1;
    [PTBR+5] = "0000";
    [PTBR+6] = -1;
    [PTBR+7] = "0000";

    // Code FOR IDLE
    [PTBR+8] = 69;
    [PTBR+9] = "0100";
    [PTBR+10] = -1;
    [PTBR+11] = "0000";
    [PTBR+12] = -1;
    [PTBR+13] = "0000";
    [PTBR+14] = -1;
    [PTBR+15] = "0000";

    // Stack FOR IDLE 
    [PTBR+16] = stackPage;
    [PTBR+17] = "0110";
    [PTBR+18] = -1;
    [PTBR+19] = "0000";

    if(iter==IDLE_PROCESS) then
        iter = IDLE2_PROCESS;
    else
        iter = iter+1;
    endif;

endwhile;
// PROCESS 0 IDLE

// we are using the first Process Table entry, the PID will be 0. eXpOS kernel is expected to store the PID in the PID field of the process table.
[PROCESS_TABLE ] = 0 ; // TICK
[PROCESS_TABLE +  1] = IDLE_PROCESS ; //PID
[PROCESS_TABLE +  3] = KERNEL; // USERID
[PROCESS_TABLE + 4] = RUNNING; 
//  Allocate memory page 76 for kernel stack of idle.
[PROCESS_TABLE +  11] = 76;
[PROCESS_TABLE + 12] = 0; // KPTR
[PROCESS_TABLE + 13] = 8*PAGE_SIZE; // UPTR
[PROCESS_TABLE + 14] = PAGE_TABLE_BASE; // PTBR 
[PROCESS_TABLE + 15] = 10; // PTLR
[70 * PAGE_SIZE] = [69*PAGE_SIZE + 1];



alias swapperDaemonProcessTableEntry R1;

swapperDaemonProcessTableEntry = PROCESS_TABLE + 16*SWAPPER_DAEMON;
[swapperDaemonProcessTableEntry ] = 0 ;
[swapperDaemonProcessTableEntry +  1] = SWAPPER_DAEMON ;// PID
[swapperDaemonProcessTableEntry + 3] = KERNEL; // USERID 
[swapperDaemonProcessTableEntry + 4] = CREATED; // STATE
//  Allocate memory page 82 for kernel stack of idle.
[swapperDaemonProcessTableEntry +  11] = 82; // USER AREA PAGE NUMBER	 
[swapperDaemonProcessTableEntry + 12] = 0; // KERNEL STACK POINTER (KPTR)	
[swapperDaemonProcessTableEntry + 13] = 8*PAGE_SIZE; // USER STACK POINTER (UPTR)	
[swapperDaemonProcessTableEntry + 14] = PAGE_TABLE_BASE + 20*SWAPPER_DAEMON;
[swapperDaemonProcessTableEntry + 15] = 10; // PTLR


// IDLE2 PROCESS 14

alias idle2ProcessTableEntry R1;

idle2ProcessTableEntry = PROCESS_TABLE + 16*IDLE2_PROCESS;
[idle2ProcessTableEntry ] = 0 ; // TICK
[idle2ProcessTableEntry +  1] = IDLE2_PROCESS ;// PID
[idle2ProcessTableEntry + 3] = KERNEL; // USERID 
[idle2ProcessTableEntry + 4] = RUNNING; // STATE
//  Allocate memory page 84 for kernel stack of idle.
[idle2ProcessTableEntry +  11] = 84; // USER AREA PAGE NUMBER	 
[idle2ProcessTableEntry + 12] = 0; // KERNEL STACK POINTER (KPTR)	
[idle2ProcessTableEntry + 13] = 8*PAGE_SIZE; // USER STACK POINTER (UPTR)	
[idle2ProcessTableEntry + 14] = PAGE_TABLE_BASE + 20*IDLE2_PROCESS;
[idle2ProcessTableEntry + 15] = 10; // PTLR
// [83 * PAGE_SIZE] = [69*PAGE_SIZE + 1]; // Idle 2 (Done in secondary bootstrap)


// IDLE2 PROCESS 14 END







// Setting Process ID in System Status Table to 0
[SYSTEM_STATUS_TABLE+1] = IDLE_PROCESS;
// Setting CURRENT PID 2 to Idle2
[SYSTEM_STATUS_TABLE+6] = IDLE2_PROCESS;
// Setting Logout Status to 0
[SYSTEM_STATUS_TABLE+7] = 0;

// The access control variables KERN_LOCK and SCHED_LOCK of the Access Lock Table must be initialized to 0.
[KERN_LOCK] = 0;
[SCHED_LOCK] = 0;


// -- For Peterson algorithm -- //
[ACCESS_LOCK_TABLE + 3] = 0;
[ACCESS_LOCK_TABLE + 4] = 0;
[ACCESS_LOCK_TABLE + 5] = 0;
[ACCESS_LOCK_TABLE + 6] = 0;
[ACCESS_LOCK_TABLE + 7] = 0;

// -- For Peterson algorithm -- //




PTBR = PAGE_TABLE_BASE; // 29696 //as PID of idle process is 0
PTLR = 10;
[81 * PAGE_SIZE] = [69*PAGE_SIZE + 1]; // SWAPPER DAEMON
SP = 8*PAGE_SIZE; //  accessing stack  from the page table using logical address

// Issue the START instruction to start the secondary core into execution.
start;
ireturn; 