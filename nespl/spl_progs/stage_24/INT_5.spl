
// At the beginning of interrupt routine 14, extract the system call number from the user stack and switch to the kernel stack.
alias userSP R1;
alias systemCallNum R2;
alias processTableEntryAddress R3;

processTableEntryAddress = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1]*16;
// Save the user stack pointer in the process table
[processTableEntryAddress + 13]= SP;

// switch to the kernel stack
SP = [processTableEntryAddress + 11] * 512  - 1 ;
PTBR = [processTableEntryAddress + 14] ;

userSP = [processTableEntryAddress + 13];
systemCallNum = [[PTBR + 2*((userSP-5)/512)] * 512 + ((userSP-5)%512)] ;

// Change the MODE FLAG in the process tableto the system call number.
[processTableEntryAddress + 9] = systemCallNum;



// Extract the filename/file decriptor from the user stack. 
alias arg1 R4;
arg1  = [[PTBR + 2*((userSP-4)/512)] * 512 + ((userSP-4)%512)] ;

alias returnAddress R5;
returnAddress = [PTBR + 2*((userSP-1)/512)] * 512 + ((userSP-1)%512) ;





if(systemCallNum == 2) then //  Open
    alias fileName R4;

    //  Find a free Per-Process Resource Table entry.
    alias perProcessResouceTable R6;
    alias freeEntry R7;
    alias iter R8;
    perProcessResouceTable = [processTableEntryAddress + 11] * 512 + RESOURCE_TABLE_OFFSET;
    iter = 0;
    freeEntry = -1;

    // The Per-Process Resource Table has 8 entries and each entry is of 2 words. The last 16 words of the User Area Page are reserved for this.
    // The per-process resource table entry has the following format. Resource Identifier (1 word)	Index of Open File Table/ Semaphore Table entry (1 word)
    // A free entry is denoted by -1 in the Resource Identifier field.

    while(iter < 8) do 
        if([perProcessResouceTable + 2*iter] == -1) then
            freeEntry = iter;
            break;
        endif;
        iter = iter + 1;

    endwhile;

    // If there is no free entry, return -3.
    if(freeEntry == -1) then
        //  return to the user mode with -3 stored as return value indicating Process has reached its limit of resources.
            [returnAddress] = -3;

            // At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack.
            [processTableEntryAddress + 9] = 0;
            SP = [processTableEntryAddress + 13];
            ireturn;
    endif;


    // Call the open() function from the File Manager module to get the Open File table entry.
    multipush(R1,R2,R3,R4,R5,R6,R7);
    R1 = OPEN;
    R2 = fileName;
    call FILE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6,R7);

    // If Open fails, return the error code.
    if(R0 == -1 || R0 == -2 || R0 == -3) then
            //  return to the user mode with the error code stored as return value.
            [returnAddress] = R0;

            // At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack.
            [processTableEntryAddress + 9] = 0;
            SP = [processTableEntryAddress + 13];
            ireturn;
    endif;


    // Set the Per-Process Resource Table entry
    [perProcessResouceTable + 2*freeEntry] = FILE;
    [perProcessResouceTable + 2*freeEntry + 1] = R0;


    // Return the index of the Per-Process Resource Table entry.   ( success )
    // The index of this entry is the File Descriptor of the file.
    [returnAddress] = freeEntry;
endif;



if(systemCallNum == 3) then // Close
    // Argument is File Descriptor (Integer)
    alias fileDescriptor R4;

    // If file descriptor is invalid, return -1.  ( File descriptor value should be within the range 0 to 7 (both included).) 
    if(fileDescriptor < 0 || fileDescriptor > 7) then
            //  return to the user mode with -1 stored as return value indicating invalid file descriptor.
            [returnAddress] = -1;

            // At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack.
            [processTableEntryAddress + 9] = 0;
            SP = [processTableEntryAddress + 13];
            ireturn;
    endif;

    alias perProcessResouceTableEntry R5;
    perProcessResouceTableEntry = [processTableEntryAddress + 11] * 512 + RESOURCE_TABLE_OFFSET+ 2*fileDescriptor;


    // If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE, return -1.   
    if([perProcessResouceTableEntry] != FILE) then
            //  return to the user mode with -1 stored as return value indicating invalid file descriptor.
            [returnAddress] = -1;

            // At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack.
            [processTableEntryAddress + 9] = 0;
            SP = [processTableEntryAddress + 13];
            ireturn;
    endif;

    
    
    // We reached here means No file is open with this file descriptor.

    // Get the index of the Open File Table entry from Per-Process Resource Table entry. ([perProcessResouceTableEntry+1])
    multipush(R1,R2,R3,R4,R5,R6,R7);
    R1 = CLOSE;
    R2 = [perProcessResouceTableEntry+1];
    call FILE_MANAGER;
    multipop(R1,R2,R3,R4,R5,R6,R7);


    // Invalidate the Per-Process Resource Table entry.
    [perProcessResouceTableEntry] = -1;
  
    // return 0
    [returnAddress] = 0;

endif;


// At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack.
[processTableEntryAddress + 9] = 0;
SP = [processTableEntryAddress + 13];
ireturn;


